// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import{HandlerStatefulFuzzCatches} from "../../../src/invariant-break/HandlerStatefulFuzzCatches.sol";
import {MockUSDC} from "../../mocks/MockUSDC.sol";
import {YeildERC20} from "../../mocks/MockUSDC.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20/sol";
contract AttemptedBreakTest is Test{
HandlerStatefulFuzzCatches handlerStatefulFuzzCatches;
YeildERC20 yeildERC20;
MockUSDC MockUSDC;
IERC20 [] supportedTokens;
uint256 startingAmount;
address user = makeAddr("user");

function setUp(){
vm.startPrank(user);
yeildERC20 = new YeildERC20();
mockUSDC = new MockUSDC();
startingAmount = yeildERC20.INITIAL_SUPPLY();
mockUSDC.mint(user, startingAmount);
vm.stopPrank();
supportedTokens.push(mockUSDC);
supportedTokens.push(yeildERC20);
handlerStatefulFuzzCatches = new HandlerStatefulFuzzCatches(supportedTokens);
targetContract(address(handlerStatefulFuzzCatches));
}


function testStartingAmountTheSame() public view  {
assert(startingAmount==yeildERC20.balanceOf(user));
assert(startingAmount==mockUSDC.balanceOf(user));
}

function statefulFuzz_testInvariantBreaks() public {
    vm.startPrank(user);
    handlerStatefulFuzzCatches.withdrawBalance(mockUSDC);
        handlerStatefulFuzzCatches.withdrawBalance(yeildERC20);
        vm.stopPrank();
    assert(mockUSDC.balanceOf(address(handlerStatefulFuzzCatches))==0);
    assert(yeildERC20.balanceOf(address(handlerStatefulFuzzCatches))==0);
}

}